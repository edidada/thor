它真的相当有趣
在这门课中
花些精力关注
特别是在
分布式程序中，嗯，首先
事实上，我们已经使用过
其它风格的编程语言
非常多，比如
这些语言提供了我们需要的工具
并且它也能得出满意的结果
给你打包了一些非常便利的功能（特性）
供你使用
尤其是在多线程
未来我们会大量使用这些特性
它听起来好像没什么大不了的
真的是个很大的包袱，用起来不尽人意
比如说，你很难找到一个
当然了
在这门课里或是
程序中，并且在不同的机器上，我们会用它做比较
且内存安全的语言
想要编写一个完美的程序真的太难了
然后导致程序产生一些奇奇怪怪的事情
这意味着
也不用再为释放正在被使用的内存而担忧
当它不被使用时，也应该要被释放掉
还有一些看起来不太明显的问题
直到你接触
这样的程序之前
多线程协同，垃圾回收
也是相当重要的事情之一
在非垃圾回收型语言中
它总会出现一些让人迷惑的的问题
这要求你需要一大本草稿本帮助你去理解
什么时候最后一个线程
不在使用共享对象
因为只有
在这个时候，你才能释放对象
所以最终你会写很多代码
就像许多程序员会
自己动手写一堆代码那样
你知道可以实现类似引用计数这样的功能
来解决它，你也知道
当最后一个使用对象的线程结束时（需要释放它）
那真是相当的痛苦
如果有垃圾回收，这些问题都将不复存在
你可能只是一个拼写错误
它就可能导致编译器
报出非常复杂的错误信息
尝试去理解这些
错误信息不太值得了
我觉得更好、更快的方法
就是去看看出错的那一行代码
尝试去猜测它到底是什么错误
因为这门语言真是太复杂了
它没有许多让人热衷的特性
相对而言它是一门“直接了当”的语言
如果你正在纠结关于这门语言
你下一步应该学习什么的时候
有一个好东西你可以看看
你可以通过互联网搜索到这本书
好吧，现在我们谈谈多线程
在这门课里
为什么要关注多线程？
线程将是在这门课中
实现并发的重要工具
在分布式程序中
并发相当有意思
比较常见的情况是
一个程序需要同时
和多台计算机通信
客户端可能会同时和多台服务器通信
一台服务器可能会同时响应
来自不同客户端的多条请求
我们需要一种方式来解释
客户端在通信
我想要一种简单的方式
我不需要做太复杂的编程
线程就能很好的解决它
大家所说的线程
你可以这样来思考线程
你有一个程序
有一个地址空间，让我来画个小盒子
来表示地址空间
在这个地址空间里
串行执行的程序是没有多个线程的
你只有一个线程
它在这个地址空间中执行代码
它只有一个程序计数器，只有一套寄存器，一个栈
这些东西就能描述
当前的执行状态
你可以拥有多个线程，
我来画些弯弯的线条来表示它
每条线之间都是分开的
尤其是
如果这些线程同时执行
那它们就分别有一个属于自己的程序计数器
一套寄存器和一个栈
是的，每个线程都有自己的一套东西
自己的一套线程控制
他们可以在程序中不同的部分
执行每个线程
有一个不太让人注意的细节
每一个独立的线程都有一个栈
线程会在这些栈上执行
这些栈都在程序中的同一个地址空间里
所以，即使
每个线程都有它自己的栈
严格来讲他们都在同一地址空间中
如果知道正确的地址的话
不同的线程之间
是可以互相访问的他们的栈的
尽管你通常不会这么干
当你首次启动程序时
好啦
我想说的最重要的原因
就是允许程序中不同的部分
都能独立的
执行不同的动作
是因为在过去这个概念
第一次被提出的时候是这样的
你可能有一个线程
正在等待从磁盘上读数据
当它在等待的时候，你又想要
另一个线程，可能用来做计算或是
从某个磁盘的地方读取数据
或是向网络发送一条消息并等待回复
也是你使用多线程的地方之一
比如说
我们有一个程序
请求网络上不同的服务器
然后同时在等待多个回复
这就是我们要解决的问题
具体做法是
每个线程
然后在这个位置等待
当响应回复时
这个线程将会继续执行
使用多线程
可以让我们同时发起多个网络请求
所有线程都会等待回复
也不是非得在同一时间去发请求
只要它愿意，这些线程总可以做不同的事情
也允许一个活动正在等待
另一个活动可以继续执行
使用多线程的另一个重要原因是多核并行
我就写并行化吧
我们想通过线程来达到并行化的目的
并行化就是如果你有个多核机器
我确定你们每个人都能用你自己的电脑做到
如果你有一个计算繁重的工作
这不是太好
假设你的程序
你的线程将会真正的以并行的方式运行
对部分人来说这真的太重要了
但是在这门课里
这其实没什么大不了的
我们并不会把多过精力
放在这一类并行化上
在现实世界中
我们开发像服务器这样的程序
来组成分布式系统的一部分
有时让服务器
能使用多线程
能使用多核还是非常重要的
因为往往客户端
带给服务器的负载非常高
那么为什么咱们会在分布式系统中
如此关注多线程呢
第三个原因，但也可能不那么重要
就是有时候
你只是想在后台做一些事情
比如你就想周期性的去执行它
但你又不愿意在主线程
插入一些检查
比如我要做的那个动作
它应该每秒发生一次
就像你生火一样
每秒都能做
不管周期性执行做什么事情
所以，易用性也是原因
这里有个例子
也是经常会遇到的情况
就需要把工作扔到另一台机器上去执行
你可以每秒、每分钟
然后做需要周期执行的动作
这个开销是值得的，是的，这个开销
真的非常少
这依赖于你创建多少线程
然后发送网络消息
这可能会给你的机器带来巨大的负载
这真的没什么大不了的
我保证这会节约你很多时间
你不用把各种不同的
功能搞到一起
放在一行代码里
如果很不幸
也从未让他们退出
甚至是你做的更过火
是人们喜欢线程的主要原因
也是我们在这门课里使用多线程的原因
关于线程大家还有什么问题吗？
你的意思是通过单线程
来追踪不同活动的状态是吗？
如果不使用多线程会怎样？
可能因为某些原因我们不想使用线程
那么我们如何写程序？
你知道服务器
能够同时与不同客户端通信
或是客户端能同时与多个服务器通信
这时候应该使用什么样的工具？
事实上还有另一种方式
另一种主要风格
这种组织程序的方式称为异步编程
也称为事件驱动编程
你可以使用事件驱动编程
事件驱动编程的一般结构
通常它有一个线程
同时有一个循环
这个循环等待输入
或者是其它任何事件
这些事件能触发程序继续进行
事件可能是一个来自客户端的请求
可能是定时器到期，如果你在编写
都是通过事件驱动的风格来编写的
它们等待的东西是像键盘击键
或者是鼠标移动这样的事件
因此你可能会有一个单一的
只有一个控制线程的程序
这个线程有一个循环一直等待输入
无论何时有输入进来
比如收到报文，它能够找出来
是哪个客户端发送的这个报文
它有一张表格
记录这个客户端到底处于什么样的活动状态
我现在处于“读”某个文件的状态
那么它就会要求我去读下一个数据块
然后我就会去读取下一个数据块然后返回
使用线程的话
通常会变的更加方便
因为线程能让你更容易把把程序写的连贯有序
你就一溜写下来几行代码
计算，然后发送消息，然后等待响应
这比在只有一个线程里
把一个活动给分割成一块一块的办法要容易多了
在事件驱动循环里
你一次只能执行一个活动
这种编程模式的问题在于
它实现起来有点痛苦
另一个潜在的缺陷
所以当你写一个负载很高的服务
使用一个单一循环的话，你知道，它相当的不自然
也很难获得多核的性能
另一方面
冒这样的风险编程
通常换来的性能提升相比多线程来说并不会太多
而且线程相对来说也很廉价
但是每个线程都有一个栈
这些消耗根本不用在意
那它就会消耗大量的内存
另外，线程调度
它是指下一步应该选择哪个线程运行
这时候切换线程执行将付出相当昂贵的代价
所以，当你只有一个服务器的时候
这个代价还是挺高的
如果使用事件驱动编程，花点时间的话
应该容易写一个
一个简单的而又五脏俱全高性能的服务
就是你需要多做点工作
你这个问题我也不会
有个很自然的想法
每个线程上运行一个精简的事件驱动循环
一个循环一个核
一个进程就是一个单独运行的程序
只有一个地址空间
一大片可供进程使用的内存
在这个进程里你可能同时会有好多个线程
它们实际上都是在同一个进程里的
我不太确定真实的答案是不是这样
但历史上，操作系统都提供了像这样的大盒子
它就是个进程
实际上这也取决于操作系统的实现
确实有个别人或一些操作系统
并不关心你的进程内部到底发生了什么事情
也不关心你使用什么语言
不关心操作系统内部的业务逻辑
在进程内部能运行多个线程就行了
好，如果在你的机器上运行了不止一个进程
比如一个编辑器或是编译器
操作系统需要让它们彼此分开
你的编辑器和你的编译器
都有自己的内存空间
他们之间无法看到彼此的内存
不同的进程之间不会有交集
你的编辑器可能有多个线程
你的编译器也可能有多个线程
但是他们都处于各自的世界
但是在同一个进程中，线程与线程之间可以共享内存
但进程之间是没有交集的
这类软件的传统结构就是这样
问题：当上下文切换时，是所有线程都在切换吗？（内心：这届同学有点难搞）
你只有一个单核机器
这意味着在同一个时刻你只能做一件事情
你这样想
你打算在你的机器上运行多进程
反复的分配给这两个程序
当硬件时钟到期时
这件事件是在进程级别上做的
这有点复杂，好
让我们重新再思考这个问题
我们使用的线程最终是由是操作系统线程所提供的
当操作系统上下文切换时
就是不同的线程之间产生切换时
操作系统是知道这一切的
所以操作系统可能会清楚
这儿有两个线程在这个进程中，有三个线程在那个进程
当时钟到期时
操作系统会基于一些调度算法选择一个不同的线程来运行
在这个进程中的线程和另一进程中的线程可能是不同的
所以这可能需要两个阶段去调度
首先操作系统选择一个线程去运行
好啦，线程真的很方便
大多数时候，使用它
就能让你在每个线程中写出非常普通、连贯的代码
然而，事实上写多线程程序是有些挑战的
其中一个是共享数据
关于线程模型，牛逼的地方在于
这些线程共享地址空间，共享内存
如果某个线程在内存中创建了一个对象
在其它线程中你也能使用它
你可以创建个数组或是别的什么东西
所有不同的线程都能读写
这就存在一些临界情况
如果你你持有一些你关注的状态
可能你会缓存一些数据
当其中一个线程正处理一个客户端的请求的时候
首先它会先查一下缓存中的数据
但是这个共享缓存，每个线程都能读
当线程里有新的信息时
线程可能会向缓存里写入数据进行更新
所以这真的很厉害
你可以共享内存
如果你不关心多线程之间共享内存的话
有个经典的例子
在不同的线程之间共享
如果你不做一些特殊处理的话
为什么？
无论何时你在多线程中读写共享数据
总是存在一种可能性
你得牢记
在同一时刻，总有其它的线程可能也正在查看
或是修改这个共享数据
所以这里有个很明显的问题
这里再总结一下
实际上机器运行的并不是这样的代码
而是由编译器吐出来的机器码
机器码长啥样呢
所以你可以假设所有的线程
都在执行这行代码
谁知道程序员心里想的啥呢
可能他就是这么想
但是碰巧这样写并不正确
这个问题不错
这些独立的指令是不是原子的
答案是有些是，有些不是
从某种意义上来说，如果有两个处理器
而不是一个混合的值
其它尺寸大小的未必就这么简单
这依赖于处理器和更复杂的指令
比如微处理器上的自增指令
未必就是原子的
尽管这些指令存在原子版本的
好，咱们继续。所以这是一个非常经典的错误
因为你将会做大量的多线程编程
且存在共享状态
但是对我们来说
另一些线程正在结束这段代码
第一个处理器能够
那么第二个处理器就能看到第一个处理器存储的值
好了，你可以通过上面这种方式理解这个术语
加个锁就行了
你知道，作为一个程序员
你心中应该有一些办法如何给数据加锁
只有在持有锁的时候，这个共享数据才能被使用
到后面你就会明白
在后面的教程里你可能就会用到
加在这一段使用共享数据的代码前面
无论哪个线程执行到这里
只有足够幸运的那个线程才能第一个抢到锁
然后执行所有这些代码
在结束之前，另一个线程都不能继续
你可以考虑把这些在锁中间的代码封装起来
就像这一堆东西
记住，尽管这里只有一行代码
对于必须加锁的人来说
你可以认为锁能把这一连串的代码变成一个原子操作
你是……胆子小吗，能不能再说一遍？
在这里
就只有一个变量
实际上三个不同变量
他们一点关联都没有
在这个锁里的任何位置
他们并没有什么关联
在程序员脑袋中
你只需要说
在任意时刻，你修改其中任意一个
有些复杂的数据结构
任何时候你若打算修改它
当然，树是有许多对象组合而成的
任何时候，你打算修改任何
和这个数据结构关联的东西
你都得先拿到这样的锁
当然，包含许多对象
以及对象的集合的修改
因为你可能会分配一个新的树节点
但是程序员必须想出一个策略
保证在同一时刻
数据结构只在一个核上被使用
所以
需要创建一个甚至是多个锁
有许多许多加锁的方案
应用到树上
你可以想象一棵树上所有的树节点只有一个锁
程序员可以制定一些策略来分配锁
在脑子里记住数据之间关系
这里的这个锁其实非常简单
它是一个锁对象
不用给一个对象中
所有变量都加上锁吗？
当你请求锁的时候
它在做什么
它就是想拿到这个锁，这就是它的作用
其它任何人想尝试获得锁对象
所以在某个地方
有许多（听不懂。。。）
所有这些动作都是获取这把锁
其它任何人想获得它
作为程序员，我们使用锁保护什么
完全由我们自己决定
让锁私有会不会好些
数据结构的私有数据
我们假设有个城市的分区图
你可能希望，尽管这不是真的
地图内部需要有一把锁来保护它
这是个合理的策略
有了这些会怎样？
如果你定义了一个
需要加锁使用的数据结构
这个锁是内部私有的
数据结构的每个方法都有责任
请求这把锁
用户，数据结构可能永远都不知道有这把锁的存在
这个相当合理
但是唯一点需要打破
好吧，有几件事，其中之一是
如果程序员知道这个数据从未被共享
他们可能会感觉烦恼
因为他们得多付出锁的开销
他们清楚这没必要加锁
所以这是个潜在的问题
另一件事
如果有任何内部数据结构依赖
比如我们有两个带有锁的数据结构
他们可能会互相使用
这可能会导致产生环和死锁
死锁可以被解决
但常规解决死锁的方法
需要把锁拿到实现的外面来
放到调用代码的地方（注：把函数里面的锁，移到外面）
后面有机会我们会讲到它的
不过对于隐藏锁细节的代码来说
这是个不太好的方法
其中之一是你需要解决
同时访问数据的加锁策略
另一个方案是你可以让你的代码不要共享数据
如果可以的话，这种方法会更好
因为这会降低复杂性
它和指导线程运作有关
当我们正在执行涉及到多线程情况下的加锁时
可能并不知道其它线程也在加锁
他们只是想在没有人干涉的情况下拿到数据
但也有一些情况
你确实就是故意的想让不同的线程之间
互相受到制约
我就是想等着你
比如你生产某些数据
但是你又和我不是同一个线程
你生产数据
我想在你生产完数据前一直等待
直到你完成后，我再去读取
然后需要等待所有线程都执行结束
所以当我们想
特意的互相等待的时候
你要是做完了咱们的教程的话
就能知道很多了
发送到另一个线程的工具
也有一些其它工具
它更多的用于特殊的目的
这东西很牛逼
如果有些线程在那里等着（马儿不走了）
你想周期性的“踢”它一下（类似马儿，抽它一下）
但你不确定哪些线程是否正在等待你
如果它在等你，你就踢它一下
这样它就知道它需要
继续做它应该要做的事情
相当牛逼
然后等待它们结束
线程最终的致命错误是死锁
死锁是一个一般性问题
有时你运行到线程中的某个位置
我来画个箭头
然而不幸的是
在锁中这种情况特别常见
这就死锁了
这至少需要他们都能抢到第一把锁
然后继续执行到他们需要第二把锁的位置
现在它们都在永远互相等待着对方
它们都无法继续进行下去
也没有人能释放掉刚拿到的锁
通常什么都不会发生
所以如果你的程序像机器一样停下来
什么也不干的时候
你应该要好好查查
这是一个使用多线程的例子
不同风格的方案里
咱们可以谈谈多线程编程里的一些细节
首先
你们可能知道
包含有许多链接指向了其它的页面
把这些链接指向的页面提取出来
抓取这些页面后
它应该要能够停止
另外
如果你不关心的话
你可能会永远无休止的
在循环中进行下去
你的爬虫永远无法结束
所以爬虫的工作之一就是需要记住
它抓取过的页面
或是已经开始抓取的页面
对于任何正在抓取中的页面
都不应该有第二次抓取
你可以想象
它是一个树结构
这个树结构是一个
我们想避开环
需要花点时间
但是服务器又很慢
因为网络有较长的延迟
所以你完全不会想一次只抓取一个页面
除非你想让你的爬虫运行个数年
如果你同时抓取许多页面的话
这个成本太高了
我会达到某些限制
你需要使用并行化的方式
持续的增加抓取页面的数量
直到达到呑吐极限
也就是每秒你抓取的页面数量
不在增加为止，也就是并发数的增加
这时候也耗尽了网络带宽
所以，我们希望利用并行化的方式抓取
最后一个挑战
有时候也是最难解决的问题
当爬虫运行结束
一旦我们已经抓取了所有的页面
就需要停止爬虫
但是我确实需要写一些代码
来表明：啊哈
所有的页面都已经抓取了
我已经想出了一些方案
什么时候结束被证明是
最难的一部分
所以我的第一个爬虫是一个串行化的爬虫
这段代码是可以用的
后面你会看到它的
进行深度优先搜索
有件比较有意思的事情
目的就是为了记住
它所抓取过的页面
这是最有意思的部分
如果没有被抓取过
然后递归的调用它自己
对于所有的页面
它会把这些页面传递给自己
它只有一个表格
当我调用递归的抓取的时候
它又抓取了很多页面
在它返回后，我需要意识到
你知道，在抓取实例的外面，需要意识到
某些页面是已经抓取过的
所以我们十分依赖于
所以在底层
传递给
因此这些调用共享同一个对象和内存的指针
而不是（对象）的拷贝
有什么问题吗
这段代码显然没有解决
之前提到的问题
放在这段代码的某个位置
为了让大家开心一下……
老爹，让我偷个懒
它们都找到了
完全相同的一组网页
这正是我们期望看到的输出
每个打印出一行
我将看到什么结果
我们的期望是并行爬取网页
为什么
它不会等待在
它将迅速执行完循环
所以我们很可能只会看到第一个网页
我运行它
唯一被找到的网页
混在了一起
完全不起作用
我马上会展示其中一个
（它）使用了共享数据
现在（要讲的）是共享数据的
这只是众多使用共享数据
这段代码明显
最大的不同之处在于
它做了两件事
所有爬取完成的时刻
它也会处理共享表格
执行在
但它们中的每一个是被
而不是作为函数调用
但是它们都共享一个状态表
我在这段代码前后加上互斥锁
所以这里的危险是
两个线程恰好在处理
在两个不同的网页都出现过
之后它们都会去爬取这个网页
所以我们需要在那里加锁
希望能读取当前的表格内容
这正是锁
有任何问题吗
之后另一个有趣的事情
是线程的启动
（这个同学的）问题是
某种意义上聚集了
所有的不同的东西
这里只有两个对象
但是可以是更多
只是为了方便
才它们放在一起
并没有什么深层意义
在同一个结构体里
用于取出结构体里的元素
我只是刚巧把它们
这绝对不是说
仅此而已
（学生的）问题是
但在前一个例子里
如他所说
我们传递指针
是因为我们希望
内存里有一个对象
所以它们需要一个
指向同一个对象的指针
所以我们需要找到你们自己的结构体
某种你用来传递指针的语法
这个变量是指向堆上数据的指针
所以不管怎样，它是个指针
它总是以引用形式传递
它必须是语言内置的
因为有些古怪的事情
现在我们想要
或一个匿名函数
然后我们调用了这个函数
你把一个函数声明成
然后给出函数参数
你在声明某种常量对象
这是声明常量函数的方式
我们这么做是因为我们想要
来运行我们刚声明的这个函数
然后我们必须要调用这个函数
所以我们在这里
我们这么做
原因是
我们要调用的函数的名字
但我们也想要做一点别的事情
所以我们定义这个小辅助函数
在外层函数退出之前
用于帮助协作
有一个计数器
来减小计数器
等待计数器归零
用于等待若干事件结束的方式
它在很多不同场景中
结束
直到所有的减一操作完成
我们声明这种函数的原因
基本上是为了能够
这就是为什么
我不记得
但整个程序没有失败
的错误有哪些
这对我们是个麻烦
而且总是会被调用
不管包含它的函数
是以何种原因结束的
或类似的机制
于是同时
它们不是语言的一部分
非常传统且古老的原语
所有的语言都有
这是最常见的用法
如果函数体里访问了一个变量
这个变量的定义在外围的函数里
内部函数使用的变量
和外部函数中的
是同一个变量
指代的
是同一个变量
所以当内部函数
表示它指代的是和这里相同的变量
所以你可能觉得我们可以摆脱
就让内部函数完全不含参数
直接使用
因为能让我们少打些字
变量的内容
看外部
如果我们看外部函数的
有时这正是你们想要的
内部函数当然
我们也可以那么做
但是这段代码的
给内部函数一个私有拷贝的方式
你说我们不需要
我们当然需要这个技巧
访问一个定义在
（而是）你改变了这个变量
这种改变对于内部函数
内部函数自己需要一个变量的拷贝
本质上是复制一份
能跑通的原因
我会给你展示一下
错误的代码
这只是些可怕的细节
当你遇到这个问题时
你可以尝试想弄清楚细节
这是个很好的问题
我重复一遍
如果你有一个内部函数
访问定义在外部的变量
但是外部函数返回之后
内部函数的变量将指向哪里
由于外部函数已经返回
或者说闭包
使用了外部函数里的变量
我们实际上会
编译器会分配堆内存
这些变量的当前的值
两个函数将找到
变量不会被分配在栈上
如你可能预期的
变量会被放到堆上
当外部函数返回时
对象仍然在堆上
内部函数还是能够访问到它
之后垃圾回收器负责
监测最后一个
涉及那段堆的函数退出
返回
这段代码使用这个技术
等待它的直系孩子结束
当然
然后返回
会发生什么
你会得到不正确的运行结果
把锁注释掉
问题是：如果我运行这段不加锁的代码
我将会看到什么
那将是个错误
我运行无锁的代码
我们可能在浪费时间
实际上我从来没有看到它出错
而线程有几百个指令
两个线程同时执行到这几个指令
且犯错的几率非常低
它通常运行良好
但当客户在他们的电脑上运行时
总是可能会出问题
看起来非常合理
实际它上告诉我们
但是真正关键的是
我们读了一个变量
读取的内容是之前写入的
并且（这两个操作）中间
没有锁的释放和申请
之后没有任何锁介入
它工作的原理
它使用了大量的内存
基本上对于每一个内存位置
都被分配了少量内存
用于跟踪哪些线程
最近读取或者写入了任何内存位置
然后
它也跟踪
线程申请锁和释放锁
以及别的强制线程
以非并发形式运行的
同步活动
然后被读取
我必须要思考一下
当然一个不完美的情况是
如果你不执行任何代码
它将不会分析
它并不是做静态分析
不会基于源代码作出判断
一次具体的程序运行
所以如果这次
某些恰好读写共享数据的代码
这是需要小心的地方
你需要设置某种测试装置
以确保所有的代码
这些敏感代码真的同时执行交织在一起
它没有看到两个线程
我们知道
我们已经手动运行了过几次
很久之后有一个读操作
没有锁隔开
它创建了多少个线程
最多有多少个并发的线程
没有一个明显的
同时存在线程的
如果你爬取真实的网络
我们当然不希望
意外地创建了数十亿计的线程
因为每个（线程）
占据一定量的内存
它确实创建太多线程
最好有一种方式
但是不会更多
一个方式是预先创建
一个固定大小的线程池
它的实现方式显著不同
而不是共享内存
回忆之前的版本
必须加锁
这个版本没有这样一个（共享）的表格
没有共享内存
它有一个表格
创建
一棵函数调用树
以对应图结构的搜索
这个版本
一个函数的树形结构
在结束时
读取数据
我们想象
现在读取
它遍历
这些从爬取的网页中获得的
注意到
可能有趣的事情是
也不共享任何对象
所以我们不必担心锁
这是通信的例子
而不是通过
你们这样理解
他们希望你这么思考
发送和接收操作
有一个互斥锁
使用了互斥锁
你可以在不同的线程中
发生的事情是
垃圾回收器很快看到
你能重复一遍吗
这样开始整个流程
能够注意到
它更复杂
你真正担心的是
我们是否真的能够并行启动
因为
然后退出
它可以永不退出
它将一直等待
事实上我们的助教安排了一场展示
