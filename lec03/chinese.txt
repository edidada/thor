好啦，咱们开始上课
这也是在咱们这门课里
关于如何构建大型存储的文章
关于如何构建大型存储的文章
这里“大型存储”是一个很大的话题
为什么是存储？
因为存储被证明是一种关键抽象
如果你还不知道的话
你可以想象在分布式系统中
你希望使用的各种不同的抽象
你希望使用的各种不同的抽象
但事实表明
简单的存储接口往往更有用而且更加通用
简单的存储接口往往更有用而且更加通用
构建分布式系统
大多都是关于如何设计存储系统
或是设计其它类型的系统
在它的底层
运行着一个不错的大型分布式存储系统
运行着一个不错的大型分布式存储系统
运行着一个不错的大型分布式存储系统
所以我们会更加关注
如何为大型分布式存储系统设计一个优秀的接口
如何为大型分布式存储系统设计一个优秀的接口
以及如何设计存储系统的内部结构
这样它才具备良好的行为
通过阅读这篇论文可以让我们起步
通过阅读这篇论文可以让我们起步
论文也涉及到很多本课程常出现的话题
论文也涉及到很多本课程常出现的话题
主要包括并行性能、容错、复制和一致性
主要包括并行性能、容错、复制和一致性
这也是一篇非常优秀的系统论文
从硬件到软件
到最终构建出整个系统都有涉及
到最终构建出整个系统都有涉及
尽管这是在学术会议上发表的论文
尽管这是在学术会议上发表的论文
在现实世界中也使用了相当长的时间
所以，在这里
我想聊聊一点关于分布式存储系统的空间
我想聊聊一点关于分布式存储系统的空间
你需要做大量的工作才能让他变得正确
会有一些特殊的讲述方式
在未来很多系统里你将会接触到
人们设计大型分布式系统
为了获得巨大的综合性能
为了获得巨大的综合性能
因此有个很自然的想法
如果你将数据分片到成百上千台服务器上
如果你将数据分片到成百上千台服务器上
你会发现出错成了常态
你不可能靠人工去发现并纠正这些错误
实现容错最有用的一种方法是使用复制
实现容错最有用的一种方法是使用复制
只需保留两三个或更多数量数据副本
只要其中有一个失败，你就可以使用另一个
并使数据看起来是行为良好的
以及网络中所有不同服务器和客户端之间的额外通信
以及网络中所有不同服务器和客户端之间的额外通信
这样性能也就变低了
当然这也违背了我们的初衷
当然这是绝对的
所以这就会导致你需要在
性能目标和实现良好的一致性之间做权衡
性能目标和实现良好的一致性之间做权衡
并因此付出一些代价
我把这些东西写在这里
有很多人都不太愿意在良好的一致性（强一致性）上面花费精力
有很多人都不太愿意在良好的一致性（强一致性）上面花费精力
有很多人都不太愿意在良好的一致性（强一致性）上面花费精力
在接下来的课程里我将会讨论更多关于良好一致性的话题
在接下来的课程里我将会讨论更多关于良好一致性的话题
在接下来的课程里我将会讨论更多关于良好一致性的话题
在数百台机器上的构建的理想的强一致模型的系统
在数百台机器上的构建的理想的强一致模型的系统
这是思考强一致的一种最直觉的方式
这是思考强一致的一种最直觉的方式
这是思考强一致的一种最直觉的方式
你可以想象你有一台服务器
这里假设它是单线程服务
在同一时刻它处理来自多个客户端的请求
在同一时刻它处理来自多个客户端的请求
首先会从中挑选一个出来
首先会从中挑选一个出来
我有一些数据记录在这个表中
然后我们打算更新这个表
如果一条请求进来读取它
只需要把写入的数据拉出来就行了
这里有一条法则
即同一时刻，只处理一条请求
即同一时刻，只处理一条请求
任何请求看到的数据
都能反应出在这之前所有的有序的操作
这个行为仍然没那么简单
你不得不花上几秒的时间去考虑一些事情
你不得不花上几秒的时间去考虑一些事情
你不得不花上几秒的时间去考虑一些事情
比如我们有几个客户端
现在有别的事情发生了
那么这两个客户端看到的结果是多少？
很好，这个问题不错
我假设它们是在同时发起的请求
这里不足以判断客户端是否收到了第一条请求的回复
这里不足以判断客户端是否收到了第一条请求的回复
不足以判断第一条请求是否被处理
也不足以判断服务器是以何种方式处理的它们
也不足以判断服务器是以何种方式处理的它们
也不足以判断服务器是以何种方式处理的它们
当然了，如果它先处理这个请求
然后再处理这条请求
提出这个问题的目的是想说明
即使是在一个非常简单的系统里也会存在模棱两可的结果
即使是在一个非常简单的系统里也会存在模棱两可的结果
你没办法判断出服务器到底会先处理哪条请求
也无法判断哪条回复会被先发出去
你能做到的只是判断
所以我们肯定能看到有一些完全错误的结果
所以我们肯定能看到有一些完全错误的结果
因为我们的模型保证第二次写之后是没有问题的
它也必须是第二次写入
希望这些东西足够直白
因为它就是强一致性的直观模型
因为它就是强一致性的直观模型
问题在于单个服务器的容错能力很差
问题在于单个服务器的容错能力很差
那就什么东西都留不下来了
所以在现实世界中的分布式系统
我们实际上都会构建一个复制系统
这成为了所有问题的发源地
这里有一个最糟糕的副本设计方案
我写这个是为了警告你
每台都有一份完整的数据副本
我们可以读写另一台服务器
所以问题就来了
所以这里就导致出错了
这个设计真的不怎么样
于是我们就陷入了一种可怕的场景
他们读取到的值不同
尽管我们对正确服务的直观模型表明
但这种问题仍然以另一种方式被暴露出来
假设客户端尝试
这种事情不会在这种简单的服务模型中发生
这种事情不会在这种简单的服务模型中发生
这种事情不会在这种简单的服务模型中发生
某些地方也会变得更加复杂
有大量的解决方案可以获得更好的一致性
有大量的解决方案可以获得更好的一致性
也有大量解决方案可以获得让人感觉还能接受的一致性
也有大量解决方案可以获得让人感觉还能接受的一致性
也有大量解决方案可以获得让人感觉还能接受的一致性
就算出现一些小瑕疵也还能接受
人们知道至少在学术领域
但从这篇论文发表之后
作为学术界的一份子
我切实体会到了所有想法在工业界得以实现
这些数据多到单个磁盘远远无法存储
这些数据多到单个磁盘远远无法存储
就比如说整个互联网抓取的网页副本
以便用作未来分析
因此他们需要能高度并行化的访问海量数据
因此他们需要能高度并行化的访问海量数据
有一种建立大型存储系统的方法
假设你有一些特殊的应用程序或是采集程序
假设你有一些特殊的应用程序或是采集程序
如果你隔壁办公室的人也需要用到大型存储
因为我们都在相同的沙盒中折腾
且使用了相同的存储系统
所以就有了构建文件系统的想法
目的就是为了共享
他们需要把数据进行分割
你就能获得更高的呑吐量
而且能够让单个文件比单个磁盘还要大
而且能够让单个文件比单个磁盘还要大
因为我们构建的东西在数百台服务器之上
因为我们构建的东西在数百台服务器之上
所以我们希望这些服务器能够自动的从错误中恢复
我们并不会讨论如何把副本放到世界各地
我们并不会讨论如何把副本放到世界各地
让这样的系统能够在副本彼此相距甚远的情况下工作
让这样的系统能够在副本彼此相距甚远的情况下工作
这个单数据中心并不是面向客户的服务
这个单数据中心并不是面向客户的服务
所以他们并不会直接出售这套程序
但他们可能会出售他们使用的服务
而且它是为大型顺序文件读写以多种方式定制的
而且它是为大型顺序文件读写以多种方式定制的
比如银行余额需要有一个数据库
它没有花费过多的精力让延迟变的更低
它没有花费过多的精力让延迟变的更低
而是把重点放在巨大的呑吐量上
而是把重点放在巨大的呑吐量上
比如数兆字节的操作
一个顶级系统学术会议
这些创新研究在课堂上一定不会有的
你能很好的理解并实现它们
数量远远超过了以往学术界建立的系统所使用的机器
这篇论文提出了一个相当异端的观点
认为存储系统具有弱一致性是可以接受的
认为存储系统具有弱一致性是可以接受的
它的目的是获取更好的性能
它的目的是获取更好的性能
它的目的是获取更好的性能
但是在这篇论文里
又或是别的什么错误呢
如果你在搜索引擎上执行搜索
这些结果的排序可能也不正确
并且要清晰的标记记录的边界
这看起来是设计中最好的地方了
这两个地方完全彼此隔离起来
并能使用独立的特性进行独立设计
并能使用独立的特性进行独立设计
如果我想读取这个文件中的任意一部分
表示它会被反射到磁盘上
所以我觉得它不用写入磁盘
稍后我们讨论系统如何工作的时候再来争论这个问题
所以每次我修改这些东西都需要写入磁盘
所以每次我修改这些东西都需要写入磁盘
这篇论文并没的讨论这么多细节
因为你每秒能写磁盘的次数就那么多
因为你每秒能写磁盘的次数就那么多
使用日志而不是数据库的原因是
使用日志是因为追加日志非常高效
你有一堆最近的日志记录需要被添加
你有一堆最近的日志记录需要被添加
那就还得去磁盘上寻找一个随机位置写入一点数据
那就还得去磁盘上寻找一个随机位置写入一点数据
所以日志会让这种写操作稍稍快一些
为了把这些操作反射到磁盘上
你可能并不想从日志文件从头开始读取重建
你可能并不想从日志文件从头开始读取重建
以及一个应用程序想从某个位置读取的偏移量
论文里说客户端会尝试猜测
然后发送读请求到那个副本上
客户端实际上会缓存这些结果
最后返回数据给客户端
某个特定的文件的某个特定的偏移上的数据
某个特定的文件的某个特定的偏移上的数据
我不知道详细的细节
应用程序所链接的依赖库
然后把它们的返回结果合并起来
应用程序应该是能够容忍这种情况
你得到的数据会有稍稍不同
所以论文上说客户端会尝试
应用程序对于写的接口是类似的
应用程序对于写的接口是类似的
称赞一下这种客户端接口
我说的这个就是论文里讨论的记录追加
我说的这个就是论文里讨论的记录追加
如果有很多客户端向相同的文件里追加
客户端可能就不知道文件有多长
因为我们有一些大文件
比如许多不同客户端的日志
比如许多不同客户端的日志
如果你在读取，你可以从任何最新副本中读取内容
所以我们需要考虑这个情况
因为，如果你的系统已经运行了很长时间
因为，如果你的系统已经运行了很长时间
由于故障或其他原因
比如昨天或上周的我保持的最新的副本
比如昨天或上周的我保持的最新的副本
请告诉我要与哪些块服务器对话
应该与哪些服务器通信
所以当我们最终找到最新的副本时
如果版本号在崩溃中丢失
这种做法没有问题
不对
就像建筑物中的电源故障
就像建筑物中的电源故障
所有服务器都崩溃了，我们正在缓慢地重新启动
其他的在五分钟后才完成启动
其他的在五分钟后才完成启动
这样在崩溃时也不会丢失（版本号）
通知它们都是什么身份
收件人可能是其中之一
这个新版本号
所以它们不会丢失这个信息
如果因为电源故障或其他原因
问题很棒
我觉得你的问题已经做了解释
我觉得你的问题已经做了解释
为什么会有这么诡异的错误？
所以这里是有点问题的
我认为这行不通
因为存在这种可能性
这个领域我知道的不多
我不确定它采用哪种方式
此时，我们正在执行论文中的图二
此时，我们正在执行论文中的图二
提出了一种聪明的方法来管理这种秩序
提出了一种聪明的方法来管理这种秩序
此时这些数据并不会追加到文件中
重新发起整个记录追加操作
所以问题让人很吃惊
但是其他副本的追加操作确实成功了
但是其他副本的追加操作确实成功了
所有的副本都在追加相同的数据
如果客户端随后读取了此文件
读取的结果取决于请求的是哪个副本
但是如果记录追加成功
所有副本都是一样的
所以我们讨论的都是具有新版本号的副本
所以我们讨论的都是具有新版本号的副本
你无法分辨出这些副本的区别
你无法分辨出这些副本的区别
你无法分辨出这些副本的区别
但可能他们就是有区别
并且所有副本中的这个偏移位置都会有这个记录
并且所有副本中的这个偏移位置都会有这个记录
然后该副本将数据转发到另一个副本
沿着某种链路直到所有的副本都拿到数据
沿着某种链路直到所有的副本都拿到数据
这条链路在整个数据中心上做过了最小化跨越交换机的处理
这条链路在整个数据中心上做过了最小化跨越交换机的处理
这条链路在整个数据中心上做过了最小化跨越交换机的处理
这里没有发生版本号更改
我想你是在问一个有趣的问题
我想你是在问一个有趣的问题
你可能会认为一定哪里出错了
应该在继续进行之前将其修复
也许是因为网络消息丢失了
所以没有什么可以修复的
本该传递出去的网络消息丢失了
本该传递出去的网络消息丢失了
重传网络消息的话这就有点复杂了
重传网络消息的话这就有点复杂了
这种错误太常见了
这种错误太常见了
所以我们什么都不用改变
因为网络没有丢弃消息
但仅在（重试）以后
假设我们处于一种情况
为什么？
我在黑板上写出这个
这通常是由网络分区引起的
这是一种网络错误
好，那是问题所在
而不会产生这种可怕的裂脑情况
而不会产生这种可怕的裂脑情况
即使没有缓存，还有一种可怕的情况是这样的
该消息在网络中传递
然而给你的信息仍在传递中
如果没有一些更聪明的机制
它也已经过时
就会得到两个相互冲突的副本
翻译项目地址
请再说一次。你有一个新文件，且没有备份
好的，如果你有一个新文件，没有备份
甚至是已有文件，没有备份
你将会执行一遍黑板上画的路线
你将会执行一遍黑板上画的路线
我想追加这个文件
于是它会创建一个新记录
它一定是一段特殊分支的代码
我不知道任何版本号
也许这里最重要的是重复我们几分钟前的讨论
也许这里最重要的是重复我们几分钟前的讨论
也许这里最重要的是重复我们几分钟前的讨论
它们都一致，因为它们都执行了追加
但消息传递给某个备份时丢失
因为网络某种错误
但另外两个备份拿到了消息
但另外两个备份拿到了消息
它们都在文件中做了追加
所以现在我们有两个备份有记录
另一个没有任何记录
它会重新发送请求
也许这次信息没有在网络中丢失
对，这些备份都活着
都拥有最新的版本号
读取到的内容取决于读取哪个副本
读取到的内容取决于读取哪个副本
它将总共看到所有三个记录
如果它读取这个备份
不同的读请求会看到不同的结果
也许最糟糕的情况是
所以你可能进入这种情形
翻译项目地址
翻译项目地址
我看不懂设计者心里想的啥
我认为该系统可以设计成使副本保持精确同步
我认为该系统可以设计成使副本保持精确同步
我认为该系统可以设计成使副本保持精确同步
你们将会设计一个进行复制的系统
你们将会设计一个进行复制的系统
它能真正的让副本保持同步
这意味着必须有某种机制
为了获得高性能
这样所有这些事情就可以并行地发生
但它会暴露给应用程序一些奇怪的东西
我们希望可以相对容易地编写应用程序
我们希望可以相对容易地编写应用程序
去容忍记录的顺序不同或别的
去容忍记录的顺序不同或别的
要么自己安排选择一个顺序
要么自己安排选择一个顺序
在文件或其他内容中写入你知道的序号
在文件或其他内容中写入你知道的序号
如果应用程序真的对顺序非常敏感
你可不想把电影文件中的数据弄颠倒
你可不想把电影文件中的数据弄颠倒
而不是并发地追加记录
好
它不会让人产生令人吃惊的结果
它不会让人产生令人吃惊的结果
但我可以为你列出一些你需要考虑的事情
一个（要考虑的）是你可能
哦，实际上我们早些时候已看到了该请求
并且已经执行了或没有执行
所以你需要具备检测重复的能力
你真的需要设计系统
对于一个严格一致的系统
例如错误地拔出了磁盘
因此你可能需要把写操作分成多个阶段
这是现实世界中很多强一致的系统的工作方式
这是现实世界中很多强一致的系统的工作方式
这种技巧称为两阶段提交
以确保他们的操作历史的最后几个步骤是一样的
以确保他们的操作历史的最后几个步骤是一样的
最后，为了解决这个问题
因此，众所周知
我要意识到这些事情必须在此系统中修复
你需要更多复杂的技术使其具有强一致性
你需要更多复杂的技术使其具有强一致性
你需要更多复杂的技术使其具有强一致性
你需要建立严格一致的系统
好吧，让我花一分钟的时间
笔记中有一个链接
可能最严重的局限是
它们涉及的文件越来越多
主机就用完了内存
因此这是人们遇到的最直接的问题
这种情况越来越严重
特别是硬盘的写操作
很难处理这种有点奇怪的语义
最后一个问题是
那可能要花几十分钟甚至更长的时间
那可能要花几十分钟甚至更长的时间
好极了，我们星期四见
我们将听到这个更多课程主题的信息
